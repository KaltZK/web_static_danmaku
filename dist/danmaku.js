// Generated by CoffeeScript 1.11.1
var Danmaku;

Danmaku = (function() {
  function Danmaku(config) {
    this.config = config;
    this.el = $(this.config.el);
    this.contents = this.config.contents;
    this.colors = this.config.colors || this.config.colours;
    this.amount = this.config.amount;
    this.speed = this.config.speed;
    this.size = this.config.size || "1em";
    this.stop_flag = false;
  }

  Danmaku.prototype.start = function() {
    var i, pW, ref, results, self;
    self = this;
    this.stop_flag = false;
    $(this.el).css("overflow-x", "hidden");
    pW = parseInt($(this.el).width());
    results = [];
    for (i = 0, ref = this.amount; 0 <= ref ? i < ref : i > ref; 0 <= ref ? i++ : i--) {
      results.push(setTimeout((function() {
        return self.next_dammaku();
      }), Math.ceil(pW / this.speed * Math.random())));
    }
    return results;
  };

  Danmaku.prototype.stop = function() {
    return this.stop_flag = true;
  };

  Danmaku.prototype.next_dammaku = function() {
    return this.new_dammaku(this.sample(this.contents), this.sample(this.colors), this.next_dammaku);
  };

  Danmaku.prototype.sample = function(array) {
    return array[Math.floor(array.length * Math.random())];
  };

  Danmaku.prototype.new_dammaku = function(content, color, callback) {
    var d, left, pH, pW, sH, sW, self, timerId;
    self = this;
    d = document.createElement("p");
    d.innerHTML = typeof content === "string" ? content : content.call();
    $(this.el).append(d);
    d.style.position = "absolute";
    d.style.color = color;
    d.style.fontSize = this.size;
    d.style.whiteSpace = "nowrap";
    pH = parseInt($(this.el).height());
    pW = parseInt($(this.el).width());
    sH = parseInt($(d).height());
    sW = parseInt($(d).width());
    d.style.left = left = pW;
    d.style.top = Math.floor(Math.random() * (pH - sH));
    return timerId = setInterval((function() {
      if (left > -sW) {
        left -= Math.ceil(self.speed * 10);
        return d.style.left = left;
      } else if (self.stop_flag) {
        clearInterval(timerId);
        return d.remove();
      } else {
        clearInterval(timerId);
        callback && callback.call(self);
        return d.remove();
      }
    }), 10);
  };

  return Danmaku;

})();
